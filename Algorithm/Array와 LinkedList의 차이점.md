### Array
- 가장 기본적인 자료구조
- 논리적 저장 순서와 물리적 저장 순서가 일치
- 인덱스(index)를 이용하여 원하는 원소에 접근 가능


  #### 장점
  - 탐색의 경우, 인덱스를 알고만 있다면 O(1)의 시간복잡도를 가짐
  
  #### 단점
  - 삽입, 삭제의 경우 탐색을 완료하고(O(1)), shift해주는 과정을 거쳐야하므로 최종적으로는 O(N)의 시간복잡도를 가짐
    - 삽입 : 빈 칸을 만들어주기 위해 원소들을 한 칸씩 뒤로 shift하고, 원소를 추가
    - 삭제 : 원소를 삭제하고, 삭제한 원소의 뒤에 있는 원소들을 한 칸씩 앞으로 shift


### LinkedList
- Array의 삽입, 삭제에 대한 단점을 해결하기 위한 자료구조
- 논리적 저장 순서와 물리적 저장 순서가 일치하지 않음
- 각각의 원소들은 자신의 뒤에 어떤 원소가 오는지만을 기억함

  #### 장점
  - 원소들은 자신의 뒤 원소를 기억하고 있기 때문에 삽입, 삭제의 경우에도 shift 과정 없이 그냥 기억하고 있는 원소만을 바꿔주면 되기 때문에 O(1)의 시간복잡도를 가짐
  - 즉, 맨 앞 혹은 맨 뒤에 원소를 삽입 혹은 삭제 시에는 O(1)의 시간복잡도를 가짐
  
  #### 단점
  - 원하는 위치에 삽입 혹은 삭제를 원할 시, 해당 위치를 탐색해야하기 때문에 첫 번째 원소부터 비교를 해봐야하기 때문에 최종적으로 O(N)의 시간복잡도를 가짐
  - 즉, 탐색, 삽입, 삭제 모두 O(N)의 시간복잡도를 가짐


### 그럼 왜 LinkedList를 알아야하는가?
- Tree의 기반이 되는 자료구조
- Tree에 사용하였을 때 유용성을 드러냄


### Array와 LinkedList 비교하기
||**Array**|**LinkedList**|
|:----:|:---:|:---:|
|크기|선언 시점에 지정 (Static)|선언 시점에 지정X (Dynamic)|
|메모리 할당|Stack에 할당|Heap에 할당|
|요소 접근|Random Access (element에 index를 통해 직접적으로 접근 가능)|Sequential Access (element에 접근할 때, 처음부터 순차적으로 탐색하면서 접근)|


### 각각 어떤 상황에 사용하면 좋은가?
- Array: 데이터에 접근하는 것이 주 업무일 때
- LinkedList: 데이터를 수정하는 것이 주 업무일 때
